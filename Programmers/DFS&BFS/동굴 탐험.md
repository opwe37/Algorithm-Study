# 동굴 탐험
출처 : [https://programmers.co.kr/learn/courses/30/lessons/67260](https://programmers.co.kr/learn/courses/30/lessons/67260)

## 문제 설명

오지 탐험가인  `프로도`는 탐험 도중 n개의 방으로 이루어진 지하 동굴을 탐험하게 되었습니다. 모든 방에는 0부터 n - 1 까지 번호가 붙어있고, 이 동굴에 들어갈 수 있는 유일한 입구는 0번 방과 연결되어 있습니다. 각 방들은 양방향으로 통행이 가능한 통로로 서로 연결되어 있는데, 서로 다른 두 방을 직접 연결하는 통로는 오직 하나입니다. 임의의 서로 다른 두 방 사이의 최단경로는 딱 한 가지만 있으며, 또한 임의의 두 방 사이에 이동이 불가능한 경우는 없습니다.

탐험에 앞서 이 지하 동굴의 지도를 손에 넣은 프로도는 다음과 같이 탐험 계획을 세웠습니다.

1.  모든 방을 적어도 한 번은 방문해야 합니다.
2.  특정 방은 방문하기 전에 반드시 먼저 방문할 방이 정해져 있습니다.  
    2-1. 이는 A번 방은 방문하기 전에 반드시 B번 방을 먼저 방문해야 한다는 의미입니다.  
    2-2. 어떤 방을 방문하기 위해 반드시 먼저 방문해야 하는 방은 없거나 또는 1개 입니다.  
    2-3. 서로 다른 두 개 이상의 방에 대해 먼저 방문해야 하는 방이 같은 경우는 없습니다.  
    2-4. 어떤 방이 먼저 방문해야 하는 방이면서 동시에 나중에 방문해야 되는 방인 경우는 없습니다.  
    

위 계획 중 2-2, 2-3, 2-4는 순서를 지켜 방문해야 하는 두 방의 쌍이  `A → B`(A를 먼저 방문하고 B를 방문함) 형태로 유일함을 의미합니다. 즉, 프로도는 아래와 같은 형태로 방문순서가 잡히지 않도록 방문 계획을 세웠습니다.

-   `A → B, A → C`  (방문순서 배열 order = [...,[A,B],...,[A,C],...]) 형태로 A를 방문 후에 방문해야 할 방이 B와 C로 두 개 또는 그 이상인 경우
-   `X → A, Z → A`  (방문순서 배열 order = [...,[X,A],...,[Z,A],...]) 형태로 A를 방문하기 전에 방문해야 할 방이 X와 Z로 두 개 또는 그 이상인 경우
-   `A → B → C`  (방문순서 배열 order = [...,[A,B],...,[B,C],...) 형태로 B처럼 A 방문 후이면서 동시에 C 방문 전인 경우  
    

그리고 먼저 방문해야 할 방과 나중에 방문할 방을 반드시 연속해서 방문해야 할 필요는 없어 A방을 방문한 후 다른 방을 방문한 후 B방을 방문해도 좋습니다.

방 개수 n, 동굴의 각 통로들이 연결하는 두 방의 번호가 담긴 2차원 배열 path, 프로도가 정한 방문 순서가 담긴 2차원 배열 order가 매개변수로 주어질 때, 프로도가 규칙에 맞게 모든 방을 탐험할 수 있을 지 return 하도록 solution 함수를 완성해주세요.

## 제한 사항

-   n은 2 이상 200,000 이하입니다.
-   path 배열의 세로(행) 길이는 n - 1 입니다.
    -   path 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
    -   두 방 A, B사이를 연결하는 통로를 나타냅니다.
    -   통로가 연결하는 두 방 번호가 순서없이 들어있음에 주의하세요.
-   order 배열의 세로(행) 길이는 1 이상 (n / 2) 이하입니다.
    -   order 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
    -   A번 방을 먼저 방문한 후 B번 방을 방문해야 함을 나타냅니다.

## 입출력 예

n|path|order|result
|:----|:----|:----|:----|
9|[[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]]|[[8,5],[6,7],[4,1]]|true
9|[[8,1],[0,1],[1,2],[0,7],[4,7],[0,3],[7,5],[3,6]]|[[4,1],[5,2]]|true
9|[[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]]|[[4,1],[8,7],[6,5]]|false

## 풀이

- 방문 순서가 존재하는 방을 Map 구조(code 상 constraint)로 저장
	- key : 조건이 존재하는 방 / value : 조건
	- (key: 1,  val: 4) = 1번방을 들어가기 위해서는 4번방을 먼저 가야한다는 뜻
- visited 배열 : 방의 방문 여부를 저장
- un_entered 배열 : 방문 시도를 하였으나 조건에 걸려 들어가지 못하였을 시, 몇번 방을 방문해야 현재 방을 갈 수 있는지 저장하는 배열
	- index : 조건에 해당하는 방 번호 / value : 조건에 걸려 들어가지 못했던 방 번호
	- (index: 1, val: 4) = 1번 방을 들어가면 4번 방을 들어갈 수 있음을 뜻함

- 전체적으로 BFS 방식으로 연결된 방을 탐색
	- 연결되어 있지만, 제약이 존재하고 그 제약을 만족시키지 않았다면 방문하지 않음
	- 대신, 탐색하는 도중 제약사항이 만족 되었을 때를 대비하여 un_entered배열에 정보 저장
	- 위의 두 사항을 고려하였을 때, 탐색할 방을 저장하는 큐에 값을 입력하는 조건은 다음과 같음
		1. 현재 탐색 중인 방과 직접 연결된 방 (일반적인 BFS에서 큐에 입력하는 방식)
		2. 현재 방에 의해서 입장 제한이 풀린 방 (이전에는 방문하지 못했지만, 지금은 방문 가능한 방)
- 최종적으로 visited 배열 값이 모두 true라면, true 반환
<pre>
<code>
while(queue.head != null) {
	let po = queue.dequeue().value;
	if (constraint.has(po) && visited[constraint.get(po)] == false) {
		un_entered[constraint.get(po)] = po;
		continue;
	}
	if (visited[po]) continue;
	visited[po] = true;
	if (un_entered[po] != -1) queue.enqueue(new node(un_entered[po]));
	if (cave[po].length != 0) {
		cave[po].forEach(val => queue.enqueue(new node(val)));
	}
}
</code>
</pre>
전체 코드 : [https://github.com/opwe37/Algorithm-Study/blob/master/DFS%26BFS/CaveExploration.js](https://github.com/opwe37/Algorithm-Study/blob/master/DFS%26BFS/CaveExploration.js)
